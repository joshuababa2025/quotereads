-- Enhanced Earnings System with History and Admin Controls

-- Earnings transactions table (immutable record)
CREATE TABLE IF NOT EXISTS user_earnings_transactions (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  task_completion_id UUID REFERENCES user_task_completions(id) ON DELETE SET NULL,
  transaction_type VARCHAR(50) NOT NULL CHECK (transaction_type IN ('task_completion', 'admin_adjustment', 'withdrawal', 'bonus', 'penalty')),
  amount DECIMAL(10,2) NOT NULL, -- Can be negative for deductions
  description TEXT NOT NULL,
  admin_notes TEXT,
  admin_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  is_locked BOOLEAN DEFAULT true -- Prevents modification once created
);

-- Update user_earnings table structure
ALTER TABLE user_earnings ADD COLUMN IF NOT EXISTS last_calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
ALTER TABLE user_earnings ADD COLUMN IF NOT EXISTS is_frozen BOOLEAN DEFAULT false; -- Admin can freeze account

-- Admin settings table for auto-verification control
CREATE TABLE IF NOT EXISTS admin_settings (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  setting_key VARCHAR(100) UNIQUE NOT NULL,
  setting_value TEXT NOT NULL,
  updated_by UUID REFERENCES auth.users(id),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default auto-verification setting (enabled by default)
INSERT INTO admin_settings (setting_key, setting_value) 
VALUES ('auto_verify_tasks', 'true') 
ON CONFLICT (setting_key) DO NOTHING;

-- Function to calculate user total earnings from transactions
CREATE OR REPLACE FUNCTION calculate_user_earnings(user_uuid UUID)
RETURNS DECIMAL(10,2) AS $$
DECLARE
  total_earnings DECIMAL(10,2);
BEGIN
  SELECT COALESCE(SUM(amount), 0) INTO total_earnings
  FROM user_earnings_transactions
  WHERE user_id = user_uuid;
  
  RETURN total_earnings;
END;
$$ LANGUAGE plpgsql;

-- Function to add earnings transaction
CREATE OR REPLACE FUNCTION add_earnings_transaction(
  p_user_id UUID,
  p_transaction_type VARCHAR(50),
  p_amount DECIMAL(10,2),
  p_description TEXT,
  p_task_completion_id UUID DEFAULT NULL,
  p_admin_notes TEXT DEFAULT NULL,
  p_admin_user_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  transaction_id UUID;
  new_total DECIMAL(10,2);
BEGIN
  -- Insert transaction record
  INSERT INTO user_earnings_transactions (
    user_id, task_completion_id, transaction_type, amount, 
    description, admin_notes, admin_user_id
  ) VALUES (
    p_user_id, p_task_completion_id, p_transaction_type, p_amount,
    p_description, p_admin_notes, p_admin_user_id
  ) RETURNING id INTO transaction_id;
  
  -- Calculate new total
  SELECT calculate_user_earnings(p_user_id) INTO new_total;
  
  -- Update user_earnings table
  INSERT INTO user_earnings (user_id, total_earnings, available_balance, last_calculated_at)
  VALUES (p_user_id, new_total, new_total, NOW())
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    total_earnings = new_total,
    available_balance = new_total - COALESCE(withdrawn_amount, 0),
    last_calculated_at = NOW();
    
  RETURN transaction_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically add earnings when task completed
CREATE OR REPLACE FUNCTION auto_add_task_earnings()
RETURNS TRIGGER AS $$
BEGIN
  -- Only add earnings when status changes to completed and earnings > 0
  IF NEW.status = 'completed' AND OLD.status != 'completed' AND NEW.earnings > 0 THEN
    -- Direct insert to bypass RLS
    INSERT INTO user_earnings_transactions (
      user_id, task_completion_id, transaction_type, amount, 
      description, admin_notes, admin_user_id
    ) VALUES (
      NEW.user_id, NEW.id, 'task_completion', NEW.earnings,
      'Task completion: ' || (SELECT name FROM earn_money_tasks WHERE id = NEW.task_id),
      'Auto-generated by system', NULL
    );
    
    -- Update user earnings directly
    INSERT INTO user_earnings (user_id, total_earnings, available_balance, last_calculated_at)
    VALUES (NEW.user_id, NEW.earnings, NEW.earnings, NOW())
    ON CONFLICT (user_id) 
    DO UPDATE SET 
      total_earnings = user_earnings.total_earnings + NEW.earnings,
      available_balance = user_earnings.available_balance + NEW.earnings,
      last_calculated_at = NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Replace existing trigger
DROP TRIGGER IF EXISTS update_earnings_trigger ON user_task_completions;
DROP TRIGGER IF EXISTS auto_earnings_trigger ON user_task_completions;
CREATE TRIGGER auto_earnings_trigger
  AFTER UPDATE ON user_task_completions
  FOR EACH ROW
  EXECUTE FUNCTION auto_add_task_earnings();

-- RLS Policies for earnings transactions
ALTER TABLE user_earnings_transactions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own earnings transactions" ON user_earnings_transactions;
CREATE POLICY "Users can view own earnings transactions" ON user_earnings_transactions
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins can view all earnings transactions" ON user_earnings_transactions;
CREATE POLICY "Admins can view all earnings transactions" ON user_earnings_transactions
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM auth.users WHERE auth.users.id = auth.uid() 
    AND auth.users.email IN ('admin@anewportals.com', 'support@anewportals.com'))
  );

DROP POLICY IF EXISTS "Admins can insert earnings transactions" ON user_earnings_transactions;
CREATE POLICY "Admins can insert earnings transactions" ON user_earnings_transactions
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM auth.users WHERE auth.users.id = auth.uid() 
    AND auth.users.email IN ('admin@anewportals.com', 'support@anewportals.com'))
  );

DROP POLICY IF EXISTS "System can insert earnings transactions" ON user_earnings_transactions;
CREATE POLICY "System can insert earnings transactions" ON user_earnings_transactions
  FOR INSERT WITH CHECK (true);

DROP POLICY IF EXISTS "No updates to locked transactions" ON user_earnings_transactions;
CREATE POLICY "No updates to locked transactions" ON user_earnings_transactions
  FOR UPDATE USING (is_locked = false);

-- RLS for admin settings
ALTER TABLE admin_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage settings" ON admin_settings;
CREATE POLICY "Admins can manage settings" ON admin_settings
  FOR ALL USING (
    EXISTS (SELECT 1 FROM auth.users WHERE auth.users.id = auth.uid() 
    AND auth.users.email IN ('admin@anewportals.com', 'support@anewportals.com'))
  );

DROP POLICY IF EXISTS "Users can view auto-verify setting" ON admin_settings;
CREATE POLICY "Users can view auto-verify setting" ON admin_settings
  FOR SELECT USING (setting_key = 'auto_verify_tasks');

-- Function to auto-verify tasks after 30 seconds
CREATE OR REPLACE FUNCTION auto_verify_task(completion_id UUID)
RETURNS VOID AS $$
DECLARE
  auto_verify_enabled BOOLEAN;
  task_reward DECIMAL(10,2);
BEGIN
  -- Check if auto-verification is enabled
  SELECT setting_value::BOOLEAN INTO auto_verify_enabled
  FROM admin_settings 
  WHERE setting_key = 'auto_verify_tasks';
  
  -- Default to true if setting not found
  IF auto_verify_enabled IS NULL THEN
    auto_verify_enabled := true;
  END IF;
  
  -- Only proceed if auto-verification is enabled
  IF auto_verify_enabled THEN
    -- Get task reward amount
    SELECT emt.reward INTO task_reward
    FROM user_task_completions utc
    JOIN earn_money_tasks emt ON utc.task_id = emt.id
    WHERE utc.id = completion_id;
    
    -- Update task to completed and add earnings
    UPDATE user_task_completions 
    SET 
      status = 'completed',
      earnings = task_reward,
      completed_at = NOW(),
      admin_notes = 'Auto-verified after 30 seconds'
    WHERE id = completion_id 
      AND status = 'reviewing';
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Admin function to adjust user earnings
CREATE OR REPLACE FUNCTION admin_adjust_earnings(
  p_user_id UUID,
  p_amount DECIMAL(10,2),
  p_reason TEXT,
  p_admin_user_id UUID
)
RETURNS UUID AS $$
DECLARE
  transaction_id UUID;
  transaction_type VARCHAR(50);
BEGIN
  -- Determine transaction type
  IF p_amount > 0 THEN
    transaction_type := 'bonus';
  ELSE
    transaction_type := 'penalty';
  END IF;
  
  -- Add transaction
  SELECT add_earnings_transaction(
    p_user_id,
    transaction_type,
    p_amount,
    p_reason,
    NULL,
    'Admin adjustment by: ' || (SELECT email FROM auth.users WHERE id = p_admin_user_id),
    p_admin_user_id
  ) INTO transaction_id;
  
  RETURN transaction_id;
END;
$$ LANGUAGE plpgsql;

-- Function to toggle auto-verification (admin only)
CREATE OR REPLACE FUNCTION toggle_auto_verification(
  p_enabled BOOLEAN,
  p_admin_user_id UUID
)
RETURNS BOOLEAN AS $$
BEGIN
  -- Check if user is admin
  IF NOT EXISTS (
    SELECT 1 FROM auth.users 
    WHERE id = p_admin_user_id 
    AND email IN ('admin@anewportals.com', 'support@anewportals.com')
  ) THEN
    RAISE EXCEPTION 'Unauthorized: Admin access required';
  END IF;
  
  -- Update setting
  INSERT INTO admin_settings (setting_key, setting_value, updated_by)
  VALUES ('auto_verify_tasks', p_enabled::TEXT, p_admin_user_id)
  ON CONFLICT (setting_key) 
  DO UPDATE SET 
    setting_value = p_enabled::TEXT,
    updated_by = p_admin_user_id,
    updated_at = NOW();
    
  RETURN p_enabled;
END;
$$ LANGUAGE plpgsql;